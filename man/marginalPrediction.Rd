% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mp.R
\name{marginalPrediction}
\alias{marginalPrediction}
\title{marginalizes prediction functions}
\usage{
marginalPrediction(data, vars, n, model, uniform = TRUE,
  aggregate.fun = mean, predict.fun = function(object, newdata, ...)
  predict(object, newdata = newdata, ...), ...)
}
\arguments{
\item{data}{a \code{data.frame} containing the training data excluding the target column(s)}

\item{vars}{a character vector corresponding to columns or an integer vector giving indices}

\item{n}{an integer vector of length two giving the resolution of the uniform or random grid on \code{vars} for the first element, and the number of the rows of the training data that are sample for the second element.}

\item{model}{an object with a predict method which returns a vector or matrix. presumably this object represents a model fit.}

\item{uniform}{logical indicating whether to create the grid on \code{var} uniformly or to sample from the empirical distribution.}

\item{aggregate.fun}{what function to aggregate the predictions with}

\item{predict.fun}{what function to generate predictions using \code{model}. default is the predict method for \code{model}.}

\item{target}{a character vector of length one giving the target variable name}
}
\value{
a named list with an element "prediction" which contains an array, matrix, or vector of dimension \code{n[1]}, the column dimension of the output of \code{predict.fun}, and the dimension of the output from \code{aggregate.fun}.
}
\description{
monte-carlo integration of prediction functions
}
\examples{
X <- replicate(3, rnorm(100))
y <- X \%*\% runif(3)
data <- data.frame(X, y)
fit <- lm(y ~ -1 + X)

marginalPrediction(X, 2, c(10, 25), fit,
  aggregate.fun = function(x) c("mean" = mean(x), "variance" = var(x)))

}

